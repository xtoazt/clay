import { app, BrowserWindow, ipcMain } from 'electron';
import { spawn, exec, ChildProcess } from 'child_process';
import * as path from 'path';
import * as os from 'os';

// Try to import node-pty for real terminal emulation, fallback if not available
let pty: any = null;
try {
  pty = require('node-pty');
} catch (e) {
  console.warn('node-pty not available, using fallback');
}

let mainWindow: BrowserWindow | null = null;
const activeProcesses = new Map<number, ChildProcess>();
const activePtySessions = new Map<number, any>();

function createWindow(): void {
  // Use web build instead of deleted renderer HTML
  // HTML is now generated by TypeScript
  const webDistPath = path.join(__dirname, '../web/dist/index.html');
  const fs = require('fs');
  
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    backgroundColor: '#1e1e2e', // Catppuccin Mocha base
    frame: false,
    titleBarStyle: 'hidden',
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: false,
    },
    minWidth: 600,
    minHeight: 400,
  });

  // Try to load web build, fallback to generating HTML
  if (fs.existsSync(webDistPath)) {
    mainWindow.loadFile(webDistPath);
  } else {
    // Fallback: generate HTML on the fly
    const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clay Terminal</title>
</head>
<body>
  <div id="app-root"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>`;
    mainWindow.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(html));
  }

  // Handle window resize for terminal dimensions
  mainWindow.on('resize', () => {
    if (mainWindow && activePtySessions.size > 0) {
      const size = mainWindow.getContentSize();
      // Send resize event to renderer to update terminal
      mainWindow.webContents.send('terminal-resize', {
        cols: Math.floor(size[0] / 8), // Approximate character width
        rows: Math.floor(size[1] / 16), // Approximate character height
      });
    }
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
    // Clean up all active processes
    activeProcesses.forEach((proc) => {
      try {
        proc.kill();
      } catch (e) {
        // Ignore errors
      }
    });
    activeProcesses.clear();

    // Clean up PTY sessions
    activePtySessions.forEach((ptySession) => {
      try {
        ptySession.kill();
      } catch (e) {
        // Ignore errors
      }
    });
    activePtySessions.clear();
  });
}

app.whenReady().then(() => {
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  // Clean up processes before quitting
  activeProcesses.forEach((proc) => {
    try {
      proc.kill();
    } catch (e) {
      // Ignore errors
    }
  });
  activeProcesses.clear();

  activePtySessions.forEach((ptySession) => {
    try {
      ptySession.kill();
    } catch (e) {
      // Ignore errors
    }
  });
  activePtySessions.clear();
  
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// Get the default shell
function getShell(): string {
  if (process.platform === 'win32') {
    return process.env.COMSPEC || 'cmd.exe';
  }
  return process.env.SHELL || '/bin/bash';
}

// Create a real PTY session for interactive terminal
ipcMain.handle('create-pty-session', async (event, cwd?: string, cols?: number, rows?: number) => {
  if (!pty) {
    // Fallback to regular spawn if node-pty not available
    return null;
  }

  try {
    const shell = getShell();
    const shellArgs: string[] = process.platform === 'win32' ? [] : ['-l'];
    
    const ptyProcess = pty.spawn(shell, shellArgs, {
      name: 'xterm-256color',
      cols: cols || 80,
      rows: rows || 24,
      cwd: cwd || process.cwd(),
      env: {
        ...process.env,
        TERM: 'xterm-256color',
        COLORTERM: 'truecolor',
      },
    });

    if (ptyProcess.pid) {
      activePtySessions.set(ptyProcess.pid, ptyProcess);
    }

    // Setup event handlers
    const result = {
      pid: ptyProcess.pid || 0,
      onData: (callback: (data: string) => void) => {
        ptyProcess.onData(callback);
      },
      onExit: (callback: (exitCode: number, signal?: number) => void) => {
        ptyProcess.onExit((info: any) => {
          if (ptyProcess.pid) {
            activePtySessions.delete(ptyProcess.pid);
          }
          callback(info.exitCode || 0, info.signal);
        });
      },
      write: (data: string) => {
        ptyProcess.write(data);
      },
      resize: (cols: number, rows: number) => {
        try {
          ptyProcess.resize(cols, rows);
        } catch (e) {
          console.error('Failed to resize PTY:', e);
        }
      },
      kill: () => {
        if (ptyProcess.pid) {
          activePtySessions.delete(ptyProcess.pid);
        }
        ptyProcess.kill();
      },
    };

    return result;
  } catch (error: any) {
    console.error('Failed to create PTY session:', error);
    return null;
  }
});

// IPC Handlers for simple command execution (non-interactive)
ipcMain.handle('execute-command', async (event, command: string, cwd?: string) => {
  return new Promise((resolve) => {
    const shellCmd = getShell();
    const isWindows = process.platform === 'win32';
    
    let execCommand = command;
    if (!isWindows) {
      execCommand = `${shellCmd} -c ${JSON.stringify(command)}`;
    }
    
    exec(execCommand, {
      cwd: cwd || process.cwd(),
      env: { 
        ...process.env,
        TERM: 'xterm-256color',
        COLORTERM: 'truecolor',
      },
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large outputs
    }, (error, stdout, stderr) => {
      if (error) {
        resolve({
          success: false,
          output: stderr || error.message,
          exitCode: error.code || 1,
        });
      } else {
        resolve({
          success: true,
          output: stdout || stderr, // Some commands output to stderr
          exitCode: 0,
        });
      }
    });
  });
});

// IPC Handler for streaming/interactive commands
ipcMain.handle('execute-command-stream', async (event, command: string, cwd?: string) => {
  return new Promise((resolve) => {
    const shellCmd = getShell();
    const isWindows = process.platform === 'win32';
    
    let args: string[] = [];
    if (!isWindows) {
      args = ['-c', command];
    } else {
      args = ['/c', command];
    }
    
    const child = spawn(isWindows ? shellCmd : shellCmd, args, {
      cwd: cwd || process.cwd(),
      env: { 
        ...process.env,
        TERM: 'xterm-256color',
        COLORTERM: 'truecolor',
      },
      shell: true,
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    if (child.pid) {
      activeProcesses.set(child.pid, child);
    }

    const result = {
      pid: child.pid || 0,
      onOutput: (callback: (data: string) => void) => {
        child.stdout?.on('data', (data) => callback(data.toString()));
        child.stderr?.on('data', (data) => callback(data.toString()));
      },
      onClose: (callback: (code: number) => void) => {
        child.on('close', (code) => {
          if (child.pid) {
            activeProcesses.delete(child.pid);
          }
          callback(code || 0);
        });
      },
      write: (input: string) => {
        if (child.stdin && !child.stdin.destroyed) {
          child.stdin.write(input);
        }
      },
      kill: () => {
        if (child.pid) {
          activeProcesses.delete(child.pid);
        }
        child.kill();
      },
    };

    resolve(result);
  });
});

ipcMain.handle('get-current-directory', () => {
  return process.cwd();
});

ipcMain.handle('change-directory', (event, dir: string) => {
  try {
    const homeDir = os.homedir();
    let targetDir = dir;
    
    // Handle ~ expansion
    if (dir.startsWith('~')) {
      targetDir = dir.replace('~', homeDir);
    }
    
    process.chdir(targetDir);
    return { success: true, cwd: process.cwd() };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('get-home-directory', () => {
  return os.homedir();
});

ipcMain.handle('get-platform', () => {
  return process.platform;
});

ipcMain.handle('has-pty-support', () => {
  return pty !== null;
});

// Handle window controls
ipcMain.handle('window-minimize', () => {
  if (mainWindow) {
    mainWindow.minimize();
  }
});

ipcMain.handle('window-maximize', () => {
  if (mainWindow) {
    if (mainWindow.isMaximized()) {
      mainWindow.unmaximize();
    } else {
      mainWindow.maximize();
    }
  }
});

ipcMain.handle('window-close', () => {
  if (mainWindow) {
    mainWindow.close();
  }
});
